# JVM虚拟机优化笔记

## 1.1 Java虚拟机的原理
虚拟机就是一台虚拟的机器。它是一款软件，用来执行一系列虚拟计算机指令，大体上虚拟机可以分为系统虚拟机和程序虚拟机。
- 大名鼎鼎的VirtualBox、VMware就属于系统虚拟机，它们完全是对物理计算机的仿真，提供了一个可运行完整操作系统的软件平台。
- 程序虚拟机典型代表就是Java虚拟机，它专门为执行单个计算机程序而设计，在Java虚拟机中执行的指令成为Java字节码指令。
- 无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。
- Java发展至今，出现过很多虚拟机，最初Sun使用的一款Classic的Java虚拟机，到现在最广泛的是HotSpot虚拟机。除Sun外，还有BEA的JRockit，目前JRockit和HotSpot都被Oracle收入旗下，大有整合的趋势。

## 1.2 认识Java虚拟机的基本结构
![jvm-structure-min](https://s0.wailian.download/2018/11/01/jvm-structure-min.png)

重点：Java堆、垃圾回收系统

## 1.3 基本概念说明
1. 类加载子系统：负责从文件系统或网络中加载Class信息，加载的信息存放在一块称之为方法区的内存空间。
1. **方法区**：就是存放类信息、常量信息、常量池信息、包括字符串字面量和数字常量等。
1. **Java堆**：在Java虚拟机启动时建立Java堆，它是Java程序最主要的内存工作区域，几乎所有的对象实例都存放到Java堆中，堆空间是所有线程共享的。
1. 直接内存：Java的NIO库允许Java程序使用直接内存，从而提高性能，通常直接内存速度会优于Java堆。读写频繁的场合可能会考虑使用。
1. **Java栈**：每个虚拟机线程都有一个私有的栈，一个线程的Java栈在线程创建时被创建，Java栈中保存着局部变量、方法参数、同时Java的方法调用、返回值等。
1. 本地方法栈和Java栈非常类似，最大不同为本地方法栈用于本地方法调用，Java虚拟机运行Java直接调用本地方法（通常使用C编写）。
1. **垃圾收集系统**：是Java的核心，也是必不可少的，Java有一套自己进行垃圾清理的机制，开发人员无需手工清理。
1. PC（Program Counter）寄存器：也是每个线程私有的空间，Java虚拟机会为每个线程创建PC寄存器，在任意时刻，一个Java线程总是执行一个方法，这个方法被称为当前方法，如果当前方法不是本地方法，PC寄存器就会执行当前正在被执行的指令。如果是本地方法，则PC寄存器为undefined，寄存器存放如当前执行环境指针、程序计数器、操作栈指针、计算的变量指针等信息。
1. **执行引擎**：是虚拟机核心的组件，它负责执行虚拟机的字节码。一般会先进行编译成机器码后执行。

## 2.1 堆、栈、方法区概念和联系
- 堆解决的是数据存储的问题，即数据怎么放、放在哪儿。
- 栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。
- 方法区则是辅助堆栈的一块永久区（Perm），解决堆栈信息的产生，是先决条件。

![jvm-new-user-min](https://s0.wailian.download/2018/11/01/jvm-new-user-min.png)

我们创建一个新的对象`User`，那么，`User`类的一些信息（类信息、静态信息都存放在方法区中）
- 而`User`类被实例化出来之后，被存储到Java堆中，一块内存空间
- 当我们去使用时，都是使用`User`对象的引用，形如`User user=new User();`，这里的`user`就是存放在Java栈中，即`User`真实对象的一个引用。

## 2.2 辨清Java堆
Java堆是和Java应用程序关系最密切的内存空间，几乎所有的对象都会存放在其中，并且Java堆完全是自动化管理的，通过垃圾回收机制，垃圾对象会自动清理，不需要显示地释放。

![jvm-memory-model-min](https://s0.wailian.download/2018/11/01/jvm-memory-model-min.png)

根据垃圾回收机制不同，Java堆可能拥有不同的结构。最为常见的就是将整个Java堆分为新生代和老年代。其中新生代存放新生的对象或者年龄不大的对象，老年代则存放年老对象。
- 新生代分为eden区、s0区、s1区，s0和s1也被成为from和to区域，它们是两块大小相等，并且可以互换角色的空间。
- 绝大多数情况下，对象首先分配在eden区，在一次新生代回收后，如果对象还存活，则会进入s0或s1区。之后每经过一次新生代回收，如果对象存活则它的年龄就加1。当对象达到一定年龄后，则进入老年代。

## 2.3 Java栈
Java栈是一块私有的内存空间，一个栈，一般由三部分组成：局部变量表、操作数栈和帧数据区。
- 局部变量表：用于报错函数的参数及局部变量。
- **操作数栈**：主要保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。
- 帧数据区：除了局部变量表和操作数栈外，栈还需要一些数据来支持常量池的解析，这里帧数据区保存着访问常量池的指针，方便程序访问常量池。另外，当函数返回或出现异常时，虚拟机必须有一个异常处理表，方便发送异常时找到异常的代码，因此异常处理表也是帧数据区的一部分。

## 2.4 Java方法区
Java方法区和堆一样，方法区是一块所有线程共享的内存区域，它保存系统的类信息，比如类的字段、方法、常量池等。方法区的大小决定了系统可以保存多少个类，如果系统定义太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出的错误。方法区可以理解为永久区（Perm）。

## 3.1 虚拟机参数
在虚拟机运行的过程中，如果可以跟踪系统的运行状态，那么对于问题的故障排查会有一定的帮助，因此，虚拟机提供了一些跟踪系统状态的参数，使用给定的参数执行Java虚拟机，就可以在系统运行时打印相关日志，用于分析实际问题。我们进行虚拟机参数配置，其实主要是围绕着堆、栈、方法区进行配置。

## 3.2 堆分配参数
1. `-XX`：对于系统级别的（JVM）配置，配置日志信息，或者配置JVM使用什么垃圾回收器
1. 非`-XX`：基本上都是对应用层面上的配置
    - `+`：启用
    - `-`：禁用

- `-XX:+PrintGC`：使用这个参数，虚拟机启动后，只要遇到GC就会打印日志
- `-XX:+UseSerialGC`：配置串行回收器
- `-XX:+PrintGCDetails`：可以查看详细信息，包括各个区的情况
- `-Xms`：设置Java程序启动时初始堆大小
- `-Xmx`：设置Java程序能获得的最大堆大小
- `-Xmx20m -Xms50m -XX:+PrintCommandLineFlags`：将隐式或显式传给虚拟机的参数输出

示例：`Test01`

总结：在实际工作中，我们可以直接将初始化的堆大小与最大堆大小设置相等，这样的好处是可以减少程序运行时的垃圾回收次数，从而提高性能。

## 3.3 新生代配置
- `-Xmn`：设置新生代的大小，设置一个比较大的新生代会减少老年代的大小。这个参数对系统性能，以及GC行为有很大的影响，新生代大小一般会设置整个堆空间的1/3到1/4左右
- `-XX:SurvivorRatio`：设置新生代中eden空间和from/to空间的比例。含义：`-XX:SurvivorRatio=eden/from=eden/to`
- `-XX:NewRatio`：设置新生代和老年代的比例：`-XX:NewRatio=老年代/新生代`

示例：`Test02`

总结：不同的堆分布情况，对系统执行会产生一定的影响，在实际工作中，应该根据系统的特点做出合理的配置，基本策略：尽可能将对象预留在新生代，减少老年代的GC次数。

## 3.4 堆溢出处理
在Java程序的运行过程中，如果堆空间不足，则会抛出内存溢出的错误（Out Of Memory）OOM，一旦这类问题发生在生产环境，可能引起严重的业务中断。Java虚拟机提供了
- `-XX:+HeapDumpOnOutOfMemoryError`：可以在内存溢出时导出整个堆信息
- `-XX:+HeapDumpPath`：可以设置导出堆的存放路径
- 内存分析工具：[Memory Analyzer](http://download.eclipse.org/mat/1.5/update-site/)

示例：`Test03`

## 3.5 栈配置
Java虚拟机提供了参数`-Xss`来指定线程的最大栈空间，整个参数也直接决定了函数可调用的最大深度。

示例：`Test04`

## 3.6 方法区
和Java堆一样，方法区是一块所有线程共享的内存区域，它用于保存系统的类信息。方法区（永久区）可以保存多少信息，可以对其进行配置，在默认情况下，`-XX:MaxPermSize=64M`为64MB。如果系统运行时生产大量的类，就需要设置一个相对合适的方法区，以免出现永久区内存溢出的问题。
- `-XX:PermSize=64M -XX:MaxPermSize=64M`

## 3.7 直接内存配置
直接内存也是Java程序中非常重要的组成部分，特别是广泛用在NIO中，直接内存跳过了Java堆，使Java程序可以直接访问原生堆空间，因此，在一定程度上加快了内存空间的访问速度。但是，说直接内存一定就可以提高内存访问速度也不见得，具体情况具体分析。
- `-XX:MaxDirectMemorySize`，如果不设置默认值为最大堆空间，即`-Xmx`。直接内存使用达到上限时，就会触发垃圾回收，如果不能有效的释放空间，也会引起系统的OOM。

## 3.8 Client和Server虚拟机工作模式
目前Java虚拟机支持Client和Server两种运行模式，使用参数`-client`可以指定Client模式，使用`-server`即使用Server模式。可以直接在命令行查看当前计算机系统自动选择的运行模式。`java -version`即可。两者区别：
- Client模式相对Server启动较快，如果不追求系统的长时间使用性能仅仅是测试，可以使用Client模式。
- Server模式则启动比较慢，原因是会对其进行复杂的系统性能信息收集和使用更为复杂的算法对程序进行优化。一般我们的生产环境都会使用Server模式，长期运行其性能要远远快于Client模式。

[JVM参数设置、分析](http://www.cnblogs.com/redcreen/archive/2011/05/04/2037057.html)

## 4.1 垃圾回收概念和其算法
垃圾回收（Garbage Collection，简称GC），GC中的垃圾，特指存于内存中、不会再被使用的对象，而回收就是相当于把垃圾“倒掉”。

垃圾回收有很多种算法：如引用计数法、标记压缩法、复制算法、分代、分区的思想。

## 4.2 垃圾收集算法
- 引用计数法：这是个比较古老而经典的垃圾收集算法，其核心就是在对象被其它所引用时计数器加1，而当引用失效是则减1。但是，这种方式有非常严重的问题：无法处理循环引用的情况，还有就是每次进行加减操作比较浪费系统性能。
- 标记清除法：分为标记和清除两个阶段进行处理内存中的对象，当然这种方式也有非常大的弊端，就是空间碎片问题，垃圾回收后的空间不是连续的，不连续的内存空间的工作效率要低于连续的内存空间。
- **复制算法**：其核心思想就是将内存分为两块，每次只使用其中一块，在垃圾回收时，将正在使用的内存中的存留对象复制到未被使用的内存块中去，之后去清除之前正在使用的内存块中所有的对象，反复去交换两个内存的角色完成垃圾收集。（Java中新生代的from和to空间就是使用这个算法）
- **标记压缩法**：在标记清除法基础上做了优化，把存活的对象压缩到内存一端，而后进行垃圾清理。（Java中老年代使用的就是标记压缩法）
- **分代算法**：根据对象的特点把内存分为N块，而后根据每个内存的特点使用不同的算法。
    - 对于新生代和老年代来说，新生代回收频率很高，但是每次回收耗时都很短。
    - 而老年代回收频率较低，但是耗时会相对较长，所以，应该尽量减少老年代的GC。
- **分区算法**：将整个内存分为N多个小的独立空间，每个小空间都可以独立使用，这样细粒度的控制一次回收多少个小空间和那些个小空间。而不是对整个空间进行GC，从而提升性能，并减少GC的停顿时间。

## 4.3 垃圾回收时的停顿现象
垃圾回收器的任务是识别和回收垃圾对象进行内存清理，为了让垃圾回收器可以高效地执行，大部分情况下，会要求系统进入一个停顿的状态。停顿的目的是终止所有应用线程，只有这样系统才不会有新的垃圾产生。同时，停顿保证了系统状态在某一个瞬间的一致性，也有益于更好地标记垃圾对象。因此，在垃圾回收时，都会产生应用程序的停顿。

## 4.4 对象如何进入老年代
一般而言对象首次创建会被放置在新生代的eden区，如果没有GC介入，则对象不会离开eden区。一般来讲，只有对象的年龄达到一定的大小，就会自动离开新生代进入老年代。对象年龄是由对象经历数次GC决定的，在新生代每次GC之后，如果对象没有被回收则年龄加1。虚拟机提供了一个参数来控制新生代对象的最大年龄，当超过这个年龄范围就会晋升老年代。
- `-XX:MaxTenuringThreshold`：默认情况下为15。
- 示例：`Test05`

总结：根据设置`MaxTenuringThreshold`参数，可以指定新生代对象经过多少次回收后进入老年代。

另外，大对象（新生代eden区无法装入时，也会直接进入老年代）。JVM里有个参数可以设置对象的大小超过指定的大小之后，直接晋升老年代。
- `-XX:PretenureSizeThreshold`
- 示例：`Test06`

总结：使用`PretenureSizeThreshold`可以进行指定进入老年代的对象大小，但是要注意TLAB区域优先分配空间。

## 4.5 TLAB
TLAB全称是Thread Local Allocation Buffer即线程本地分配缓存，从名字上看是一个线程专用的内存分配区域，是为了加速对象分配而生的。每一个线程都会产生一个TLAB，该线程独享的工作区域，Java虚拟机使用这种TLAB区来避免多线程冲突问题，提高了对象分配的效率。TLAB空间一般不会太大，当大对象无法在TLAB分配时，则会直接分配到堆上。
- `-XX:+UseTLAB`：使用TLAB
- `-XX:+TLABSize`：设置TLAB大小
- `-XX:TLABRefillWasterFraction`：设置维护进入TLAB空间的单个对象的大小，它是一个比例值，默认为64。即如果对象大于整个空间的1/64，则在堆创建对象
- `-XX:+PrintTLAB`：查看TLAB信息
- `-XX:ResizeTLAB`：自调整`TLABRefillWasterFraction`阈值

示例：`Test07`

## 4.6 对象创建流程
一个对象创建在什么位置，JVM会有一个比较细节的流程，根据数据的大小，参数的设置，决定如何创建分配，以及其位置。

![jvm-create-obj-min](https://s0.wailian.download/2018/11/04/jvm-create-obj-min.png)

## 5.x 垃圾收集器

## 6.x Tomcat性能影响实验

## 7.x 性能监控工具

## References
- 尚学堂互联网架构师课程