## 原子操作

### 1 引言
原子（atom）本意是“不能被进一步分割的最小粒子”，而原子操作（atomic operation）意为”不可被中断的一个或一系列操作” 。

### 2 术语定义

术语名称 | 英文 | 解释
---|---|-----
缓存行 | Cache line | 缓存的最小操作单位
比较并交换 | Compare and Swap | `CAS`操作需要输入两个数值，一个旧值（期望操作前的值）和一个新值，在操作期间先**比较**下在旧值有没有发生变化，如果没有发生变化，才**交换**成新值，发生了变化则不交换。
CPU流水线 | CPU pipeline | CPU流水线的工作方式就象工业生产上的装配流水线，在CPU中由5~6个不同功能的电路单元组成一条指令处理流水线，然后将一条X86指令分成5~6步后再由这些电路单元分别执行，这样就能实现在一个CPU时钟周期完成一条指令，因此提高CPU的运算速度。
内存顺序冲突 | Memory order violation | 内存顺序冲突一般是由假共享引起，假共享是指多个CPU同时修改同一个缓存行的不同部分而引起其中一个CPU的操作无效，当出现这个内存顺序冲突时，CPU必须清空流水线。

### 3 处理器如何实现原子操作
32位IA-32处理器使用**基于对缓存加锁或总线加锁**的方式来实现多处理器之间的原子操作。

#### 3.1 处理器自动保证基本内存操作的原子性

#### 3.2 使用总线锁保证原子性
所谓总线锁就是使用处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住,那么该处理器可以独占使用共享内存。

#### 3.3 使用缓存锁保证原子性
在同一时刻我们只需保证对某个内存地址的操作是原子性即可，但总线锁定把CPU和内存之间通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大，最近的处理器在某些场合下使用缓存锁定代替总线锁定来进行优化。

所谓“缓存锁定”就是如果缓存在处理器缓存行中内存区域在LOCK操作期间被锁定，当它执行锁操作回写内存时，处理器不在总线上声言LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时会起缓存行无效，在例1中，当CPU1修改缓存行中的i时使用缓存锁定，那么CPU2就不能同时缓存了i的缓存行。

但是有两种情况下处理器不会使用缓存锁定。
- 第一种情况是：当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行（cache line），则处理器会调用总线锁定。
- 第二种情况是：有些处理器不支持缓存锁定。对于Inter486和奔腾处理器,就算锁定的内存区域在处理器的缓存行中也会调用总线锁定。

以上两个机制我们可以通过Inter处理器提供了很多LOCK前缀的指令来实现。比如位测试和修改指令`BTS`，`BTR`，`BTC`，交换指令`XADD`，`CMPXCHG`和其他一些操作数和逻辑指令，比如`ADD`（加），`OR`（或）等，被这些指令操作的内存区域就会加锁，导致其他处理器不能同时访问它。

### 4 Java如何实现原子操作
在Java中可以通过锁和循环`CAS`的方式来实现原子操作。

#### 4.1 使用循环`CAS`实现原子操作
`CAS`操作正是利用了上一节中提到的处理器提供的`CMPXCHG`指令实现的。自旋`CAS`实现的基本思路就是循环进行`CAS`操作直到成功为止。

`CAS`虽然很高效的解决原子操作，但`CAS`仍然存在三大问题。
1. **ABA问题**。因为`CAS`需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用`CAS`进行检查时会发现它的值没有发生变化，但是实际上却变化了。
    - ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A就会变成1A－2B－3A。
    - 从Java1.5开始JDK的`atomic`包里提供了一个类`AtomicStampedReference`来解决ABA问题。这个类的`compareAndSet`方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。
    ```
    public boolean compareAndSet(
                   V      expectedReference,// 预期引用
                   V      newReference,// 更新后的引用
                  int    expectedStamp, // 预期标志
                  int    newStamp // 更新后的标志
    ) 
    ```
1. **循环时间长开销大**。自旋`CAS`如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。
1. **只能保证一个共享变量的原子操作**。当对一个共享变量执行操作时，我们可以使用循环`CAS`的方式来保证原子操作，但是对多个共享变量操作时，循环`CAS`就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量`i＝2,j=a`，合并一下`ij=2a`，然后用`CAS`来操作`ij`。从Java1.5开始JDK提供了`AtomicReference`类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行`CAS`操作。

#### 4.2 使用锁机制实现原子操作
锁机制保证了只有获得锁的线程能够操作锁定的内存区域。JVM内部实现了很多种锁机制，有偏向锁，轻量级锁和互斥锁，有意思的是除了偏向锁，JVM实现锁的方式都用到的循环`CAS`，当一个线程想进入同步块的时候使用循环`CAS`的方式来获取锁，当它退出同步块的时候使用循环`CAS`释放锁。

### `concurrent`包的实现示意图
![concurrent-min](https://s0.wailian.download/2018/10/23/concurrent-min.png)

### `CAS`应用场景
- 自旋锁
- `AtomicInteger`的`incrementAndGet()`
- 令牌桶限流器

### 示例
- `Counter`，`SpinLock`，`RateLimiter`

### References
- [聊聊并发（五）原子操作的实现原理](http://ifeve.com/atomic-operation/)
- [《Java并发编程的艺术》源码下载](http://ifeve.com/artconcurrentbook-source/)
- [JAVA 中的 CAS](https://www.xilidou.com/2018/02/01/java-cas/)